window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "pyPAM", "modulename": "pyPAM", "kind": "module", "doc": "<p>pyPAM is a Parallelized Affine invariant ensemble sampler with an optional Mixing step. It is an extension of the EMCEE sampling package.</p>\n\n<p>This method parallelizes multiple ensembles for better performance, and also includes an optional phase of shuffling walkers between ensembles. </p>\n\n<p>example usage:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code>pip<span class=\"w\"> </span>install<span class=\"w\"> </span>...\n</code></pre>\n</div>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"kn\">import</span>\n</code></pre>\n</div>\n"}, {"fullname": "pyPAM.parallel_affine", "modulename": "pyPAM.parallel_affine", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "pyPAM.parallel_affine.ParallelEnsembleSampler", "modulename": "pyPAM.parallel_affine", "qualname": "ParallelEnsembleSampler", "kind": "class", "doc": "<p>Parallel affine invariant ensemble sampler for MCMC.</p>\n\n<p>This class implements the parallel affine invariant ensemble sampler algorithm for Markov Chain Monte Carlo (MCMC) simulations. It is designed to be run on multiple processors or cores, and is intended for use with high-dimensional problems that are difficult to sample from using traditional MCMC methods.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>n_ensembles (int):</strong>  The number of independent ensembles to run.</li>\n<li><strong>n_walkers (int):</strong>  The total number of walkers across all ensembles. Should be an even multiple of n_dim.</li>\n<li><strong>n_dim (int):</strong>  The number of dimensions in the problem space.</li>\n<li><strong>log_prob (function):</strong>  A function that computes the log probability of a given point in the problem space.</li>\n<li><strong>log_prob_args (list):</strong>  A list of additional arguments to pass to log_prob.</li>\n<li><strong>thin (int):</strong>  The thinning factor to use for saving samples. Only every <code>thin</code>th sample will be saved.</li>\n<li><strong>backend_fnames (list):</strong>  A list of file names for the backends to use. There should be one filename for each ensemble.</li>\n<li><strong>moves (list):</strong>  A list of moves to use for each ensemble.</li>\n</ul>\n\n<h6 id=\"attributes\">Attributes:</h6>\n\n<ul>\n<li><strong>n_ensembles (int):</strong>  The number of independent ensembles to run.</li>\n<li><strong>n_walkers (int):</strong>  The total number of walkers across all ensembles.</li>\n<li><strong>n_dim (int):</strong>  The number of dimensions in the problem space.</li>\n<li><strong>log_prob (function):</strong>  A function that computes the log probability of a given point in the problem space.</li>\n<li><strong>log_prob_args (list):</strong>  A list of additional arguments to pass to log_prob.</li>\n<li><strong>thin (int):</strong>  The thinning factor to use for saving samples.</li>\n<li><strong>backend_fnames (list):</strong>  A list of file names for the backends to use.</li>\n<li><strong>moves_list (list):</strong>  A list of moves to use for each ensemble.</li>\n<li><strong>backend_list (list):</strong>  A list of backends for each ensemble.</li>\n<li><strong>sampler_list (list):</strong>  A list of ensemble samplers for each ensemble.</li>\n</ul>\n\n<h6 id=\"raises\">Raises:</h6>\n\n<ul>\n<li><strong>AssertionError:</strong>  If any of the input arguments are invalid.</li>\n</ul>\n"}, {"fullname": "pyPAM.parallel_affine.ParallelEnsembleSampler.__init__", "modulename": "pyPAM.parallel_affine", "qualname": "ParallelEnsembleSampler.__init__", "kind": "function", "doc": "<p>initializes sampler class</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">n_ensembles</span>,</span><span class=\"param\">\t<span class=\"n\">n_walkers</span>,</span><span class=\"param\">\t<span class=\"n\">n_dim</span>,</span><span class=\"param\">\t<span class=\"n\">log_prob</span>,</span><span class=\"param\">\t<span class=\"n\">log_prob_args</span>,</span><span class=\"param\">\t<span class=\"n\">thin</span>,</span><span class=\"param\">\t<span class=\"n\">backend_fnames</span>,</span><span class=\"param\">\t<span class=\"n\">moves</span></span>)</span>"}, {"fullname": "pyPAM.parallel_affine.ParallelEnsembleSampler.update_backends", "modulename": "pyPAM.parallel_affine", "qualname": "ParallelEnsembleSampler.update_backends", "kind": "function", "doc": "<p>Update the backends to include a new section.</p>\n\n<p>This method updates the HDF5 backend for each ensemble by adding a new section to the file. The new section is identified by an ID string, which is appended to the name of the section.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>id (str):</strong>  The ID string to use for the new section.</li>\n</ul>\n\n<h6 id=\"raises\">Raises:</h6>\n\n<ul>\n<li><strong>AssertionError:</strong>  If the input ID is not a string, or is an empty string.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"nb\">id</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyPAM.parallel_affine.ParallelEnsembleSampler.run_sampler", "modulename": "pyPAM.parallel_affine", "qualname": "ParallelEnsembleSampler.run_sampler", "kind": "function", "doc": "<p>Run the parallel ensemble samplers.</p>\n\n<p>This method runs the parallel affine invariant ensemble samplers for a specified number of steps, with a given initial state and number of cores. It updates the backends for each ensemble to include a new section identified by an ID string, and returns the final state of the samplers.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>p_0 (ndarray):</strong>  The initial state for each walker in each ensemble, as a 3D array with shape (n_ensembles, n_walkers, n_dim).</li>\n<li><strong>n_steps (int):</strong>  The number of steps to run each sampler for.</li>\n<li><strong>n_cores (int):</strong>  The number of CPU cores to use for parallelization.</li>\n<li><strong>thin (int):</strong>  The thinning factor to use for saving samples.</li>\n<li><strong>id (str):</strong>  The ID string to use for the new backend section.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>state_list (list): A list of sampler states, one for each ensemble.</p>\n</blockquote>\n\n<h6 id=\"raises\">Raises:</h6>\n\n<ul>\n<li><strong>AssertionError:</strong>  If any of the input arguments are invalid.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">p_0</span>, </span><span class=\"param\"><span class=\"n\">n_steps</span>, </span><span class=\"param\"><span class=\"n\">n_cores</span>, </span><span class=\"param\"><span class=\"n\">thin</span>, </span><span class=\"param\"><span class=\"nb\">id</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyPAM.parallel_affine.ParallelEnsembleSampler.get_chains", "modulename": "pyPAM.parallel_affine", "qualname": "ParallelEnsembleSampler.get_chains", "kind": "function", "doc": "<p>Return the MCMC chains (samples) for each ensemble.</p>\n\n<p>This method returns the MCMC chains (samples) for each ensemble as a 4D numpy array with shape (n_ensembles, n_steps, n_walkers, n_dim).</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>samples (ndarray): The MCMC chains for each ensemble.</p>\n</blockquote>\n\n<h6 id=\"raises\">Raises:</h6>\n\n<ul>\n<li><strong>AssertionError:</strong>  If the shape of the returned samples is not as expected.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyPAM.parallel_affine.ParallelEnsembleSampler.get_last_samples", "modulename": "pyPAM.parallel_affine", "qualname": "ParallelEnsembleSampler.get_last_samples", "kind": "function", "doc": "<p>Return the last walker positions for each ensemble.</p>\n\n<p>This method returns the last walker positions (last sample points) for each ensemble as a 3D numpy array with shape (n_ensembles, n_walkers, n_dim).</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>last_samples (ndarray): The last walker positions for each ensemble.</p>\n</blockquote>\n\n<h6 id=\"raises\">Raises:</h6>\n\n<ul>\n<li><strong>AssertionError:</strong>  If the last samples returned by the method are not correct.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyPAM.parallel_affine.ParallelEnsembleSampler.mix_ensembles", "modulename": "pyPAM.parallel_affine", "qualname": "ParallelEnsembleSampler.mix_ensembles", "kind": "function", "doc": "<p>Shuffle the last samples to use as initial walker positions for the next sampling run.</p>\n\n<p>This method shuffles the last samples from each ensemble sampler and combines them into a new set of initial walker positions for the next sampling run.</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>p0_new (ndarray): The new set of initial walker positions, as a 3D numpy array with shape (n_ensembles, n_walkers, n_dim).</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyPAM.parallel_affine.ParallelEnsembleSampler.run_mixing_sampler", "modulename": "pyPAM.parallel_affine", "qualname": "ParallelEnsembleSampler.run_mixing_sampler", "kind": "function", "doc": "<p>Run the parallel ensemble samplers with N mixing steps plus a final sampling run.</p>\n\n<p>This method runs the parallel affine invariant ensemble samplers with a specified number of mixing steps, followed by a final sampling run. It takes an initial state, a list of numbers of steps to run at each mixing stage, the number of CPU cores to use for parallelization, the number of mixing stages to run, a thinning factor, and a list of ID strings for the backend sections for each mixing stage.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>p_0 (ndarray):</strong>  The initial state for each walker in each ensemble, as a 3D array with shape (n_ensembles, n_walkers, n_dim).</li>\n<li><strong>n_steps_list (list):</strong>  A list of integers specifying the number of steps to run each sampler for at each mixing stage.</li>\n<li><strong>n_cores (int):</strong>  The number of CPU cores to use for parallelization.</li>\n<li><strong>n_mixing_stages (int):</strong>  The number of mixing stages to run.</li>\n<li><strong>thin (int):</strong>  The thinning factor to use for saving samples.</li>\n<li><strong>id_list (list):</strong>  A list of ID strings for the backend sections for each mixing stage.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>state_list (list): The final state of the samplers, as a list of sampler states.</p>\n</blockquote>\n\n<h6 id=\"raises\">Raises:</h6>\n\n<ul>\n<li><strong>AssertionError:</strong>  If any of the input arguments are invalid.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">p_0</span>, </span><span class=\"param\"><span class=\"n\">n_steps_list</span>, </span><span class=\"param\"><span class=\"n\">n_cores</span>, </span><span class=\"param\"><span class=\"n\">n_mixing_stages</span>, </span><span class=\"param\"><span class=\"n\">thin</span>, </span><span class=\"param\"><span class=\"n\">id_list</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyPAM.parallel_affine.ParallelEnsembleSampler.get_flat_samples", "modulename": "pyPAM.parallel_affine", "qualname": "ParallelEnsembleSampler.get_flat_samples", "kind": "function", "doc": "<p>Return the MCMC samples in a flat shape.</p>\n\n<p>This method returns the MCMC samples in a flat shape, with dimensions (n_ensembles<em>n_steps</em>n_walkers, n_dim).</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>flat_samples (ndarray): The flattened MCMC samples.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyPAM.parallel_affine.ParallelEnsembleSampler.reset_backends", "modulename": "pyPAM.parallel_affine", "qualname": "ParallelEnsembleSampler.reset_backends", "kind": "function", "doc": "<p>Reset the backends, removing all previous samples.</p>\n\n<p>This method resets the backends by removing all previous samples from the MCMC chains. This can be useful when starting a new sampling run from scratch.</p>\n\n<h6 id=\"raises\">Raises:</h6>\n\n<ul>\n<li><strong>Warning:</strong>  A warning message is printed to the console indicating that the backend has been reset.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyPAM.parallel_affine_utility", "modulename": "pyPAM.parallel_affine_utility", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "pyPAM.parallel_affine_utility.plot_single_ensemble_mixing_distributions", "modulename": "pyPAM.parallel_affine_utility", "qualname": "plot_single_ensemble_mixing_distributions", "kind": "function", "doc": "<p>Plots 1D marginal posterior distributions for each parameter and mixing stage in a separate figure for each ensemble.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>paie_sampler (ParallelEnsembleSampler):</strong>  A parallel ensemble sampler object.</li>\n<li><strong>fname (str):</strong>  The filename to save the plot.</li>\n<li><strong>n_bins (int):</strong>  The number of bins for the histogram.</li>\n<li><strong>xlim (list of list):</strong>  The limits for the x-axis for each parameter.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>tuple: The figure and axes objects.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">paie_sampler</span>,</span><span class=\"param\">\t<span class=\"n\">fname</span><span class=\"o\">=</span><span class=\"s1\">&#39;parallel_affine_example_dist&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">n_bins</span><span class=\"o\">=</span><span class=\"mi\">100</span>,</span><span class=\"param\">\t<span class=\"n\">xlim</span><span class=\"o\">=</span><span class=\"p\">[[</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">]]</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyPAM.parallel_affine_utility.get_data_all_runs", "modulename": "pyPAM.parallel_affine_utility", "qualname": "get_data_all_runs", "kind": "function", "doc": "<p>gets data from multiple runs and multiple ensembles. Outputs a list of datasets. D[0] = data from all runs from ensemble 0. D[0][0] = data from run 0 of ensemble 0</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>paie_sampler:</strong>  a ParallelEnsembleSampler object</li>\n<li><strong>flat:</strong>  a boolean flag indicating whether the chains should be flattened</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>data_list: a list of numpy arrays, with each array containing the MCMC chain samples for an ensemble. The arrays are nested within a list, with the outer list containing arrays for each ensemble.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">paie_sampler</span>, </span><span class=\"param\"><span class=\"n\">flat</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyPAM.parallel_affine_utility.get_data_dict_from_backend", "modulename": "pyPAM.parallel_affine_utility", "qualname": "get_data_dict_from_backend", "kind": "function", "doc": "<p>Extracts MCMC chain data from an HDF5 backend file and returns it as a dictionary.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>fname (str):</strong>  The name of the HDF5 file to read.</li>\n<li><strong>flat (bool, optional):</strong>  Whether to flatten the MCMC chains into a 2D array. Defaults to False.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>dict: A dictionary where each key corresponds to a chain in the backend file, and the value is the chain data.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">fname</span>, </span><span class=\"param\"><span class=\"n\">flat</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyPAM.parallel_affine_utility.print_backend_info", "modulename": "pyPAM.parallel_affine_utility", "qualname": "print_backend_info", "kind": "function", "doc": "<p>Prints information about the contents of an HDF5 backend file.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>fname (str):</strong>  The name of the HDF5 file to read.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">fname</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyPAM.parallel_affine_utility.wrapper", "modulename": "pyPAM.parallel_affine_utility", "qualname": "wrapper", "kind": "function", "doc": "<p>Wrapper function to create and run an EnsembleSampler object in parallel.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>arg_list (list):</strong>  A list containing the arguments to initialize the EnsembleSampler object and run the MCMC sampling.\narg_list[0] (int): The number of walkers in the sampler.\narg_list[1] (int): The number of dimensions of the parameter space.\narg_list[2] (function): The log probability function to sample from.\narg_list[3] (tuple): The arguments to pass to the log probability function.\narg_list[4] (ndarray): The initial positions of the walkers in the parameter space.\narg_list[5] (int): The number of MCMC steps to take.\narg_list[6] (int): The thinning factor for the MCMC chain.\narg_list[7] (Backend): The backend object to store the MCMC chain data.\narg_list[8] (list): The list of move objects to use for the sampler.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>tuple: A tuple containing the EnsembleSampler object, the final state of the sampler, and the backend object.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">arg_list</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&_'"=,()]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.pipeline.remove(elasticlunr.stemmer);
            this.pipeline.remove(elasticlunr.stopWordFilter);
            this.addField("qualname");
            this.addField("fullname");
            this.addField("annotation");
            this.addField("default_value");
            this.addField("signature");
            this.addField("bases");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            annotation: {boost: 2},
            default_value: {boost: 2},
            signature: {boost: 2},
            bases: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();